<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://finger-bone.github.io/micro-service-crashcourse/16/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Rabbit MQ 消息队列 - 微服务速成笔记</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/color-brewer.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">微服务速成笔记</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Spring Cloud 微服务技术 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../01/" class="dropdown-item">回到 Spring</a>
</li>
                                    
<li>
    <a href="../02/" class="dropdown-item">回到 Java</a>
</li>
                                    
<li>
    <a href="../03/" class="dropdown-item">Consul 作为服务注册中心</a>
</li>
                                    
<li>
    <a href="../04/" class="dropdown-item">Consul 作为配置中心</a>
</li>
                                    
<li>
    <a href="../05/" class="dropdown-item">LoadBalancer</a>
</li>
                                    
<li>
    <a href="../06/" class="dropdown-item">Http Interface Client 与 OpenFeign</a>
</li>
                                    
<li>
    <a href="../07/" class="dropdown-item">Resilience4j 服务熔断和降级</a>
</li>
                                    
<li>
    <a href="../08/" class="dropdown-item">Resilience4j 限流</a>
</li>
                                    
<li>
    <a href="../09/" class="dropdown-item">Micrometer 监控</a>
</li>
                                    
<li>
    <a href="../10/" class="dropdown-item">Spring Gateway 网关</a>
</li>
                                    
<li>
    <a href="../11/" class="dropdown-item">Seata 分布式事务</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Spring 进阶内容 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../12/" class="dropdown-item">Reactor 框架</a>
</li>
                                    
<li>
    <a href="../13/" class="dropdown-item">Spring WebFlux</a>
</li>
                                    
<li>
    <a href="../14/" class="dropdown-item">Spring Security</a>
</li>
                                    
<li>
    <a href="../15/" class="dropdown-item">Spring Security OAuth2 认证以及 KeyCloak 用户服务</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Rabbit MQ 消息队列</a>
</li>
                                    
<li>
    <a href="../17/" class="dropdown-item">GraphQL</a>
</li>
                                    
<li>
    <a href="../18/" class="dropdown-item">gRPC</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">k8s 微服务技术 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../19/" class="dropdown-item">后端框架一览</a>
</li>
                                    
<li>
    <a href="../20/" class="dropdown-item">k8s 无状态服务基本部署</a>
</li>
                                    
<li>
    <a href="../21/" class="dropdown-item">helm 打包 istio 网关与 k8s 命令行工具</a>
</li>
                                    
<li>
    <a href="../22/" class="dropdown-item">k8s 无状态服务</a>
</li>
                                    
<li>
    <a href="../23/" class="dropdown-item">k8s 有状态服务</a>
</li>
                                    
<li>
    <a href="../24/" class="dropdown-item">服务网格</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">中间件补充 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../25/" class="dropdown-item">Nacos 服务治理</a>
</li>
                                    
<li>
    <a href="../26/" class="dropdown-item">Sentinel</a>
</li>
                                    
<li>
    <a href="../27/" class="dropdown-item">kafka 高性能消息队列</a>
</li>
                                    
<li>
    <a href="../28/" class="dropdown-item">Redis</a>
</li>
                                    
<li>
    <a href="../29/" class="dropdown-item">OTel-LGTM</a>
</li>
                                    
<li>
    <a href="../30/" class="dropdown-item">Dubbo RPC</a>
</li>
                                    
<li>
    <a href="../31.md" class="dropdown-item">Nginx</a>
</li>
                                    
<li>
    <a href="../32.md" class="dropdown-item">Treafik</a>
</li>
                                    
<li>
    <a href="../33.md" class="dropdown-item">Citus</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../15/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../17/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#ch16-rabbit-mq" class="nav-link">微服务速成 Ch16 Rabbit MQ</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">基本概念</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rabbit-mq" class="nav-link">Rabbit MQ 六大模型</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">项目配置</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rabbit-mq_1" class="nav-link">Rabbit MQ 管理界面</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_3" class="nav-link">缓冲队列模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_4" class="nav-link">工作队列模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_5" class="nav-link">扇出交换机模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">路由交换机模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_7" class="nav-link">主题交换机模式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_8" class="nav-link">可靠性保障</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_12" class="nav-link">总结</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="ch16-rabbit-mq">微服务速成 Ch16 Rabbit MQ</h1>
<p>从这章起，我们的标题褪去 Spring，变成了微服务速成。目前我们依然基于 Spring 框架，但也只是众多选择之一。</p>
<p>Rabbit MQ 是一个 AMQP 的消息队列，它是一个开源的消息队列，可以用于构建分布式系统。Rabbit MQ 是一个消息中间件，它是一个独立的服务，用于存储消息，然后消费者消费消息。</p>
<p>之所以我们要引入消息队列，主要是为了解耦。在微服务架构中，服务之间的调用是通过 HTTP 完成的，这样就会有一个问题，就是服务之间的调用是同步的。如果一个服务挂了，那么调用者就会等待，这样就会导致整个服务都挂掉。而消息队列就是为了解决这个问题的，它是异步的，即生产者生产消息后就不管了，消费者消费消息，这样就解耦了。此外，消息队列还有销峰的功能，即在高峰期，消息队列可以缓存消息，然后在低峰期消费，这样增强了系统的稳定性。当然，引入新的中间件肯定会增加复杂度和不稳定性，因此要权衡。</p>
<p>相比其它的消息队列，Rabbit MQ 有一个优点，就是它是 AMQP 的实现。AMQP 是一个消息队列的标准，它规定了消息队列的格式，这样就可以保证不同消息队列之间的兼容性。因此，Rabbit MQ 可以和其它的消息队列兼容。Rabbit MQ 也有其它的优点，例如，它支持集群，支持持久化，支持事务，支持插件等。这些丰富的特性使得它常用于微服务架构中。</p>
<p>注意，到了这一章开始 Java 语言和 Spring 框架的重要性会逐渐淡化。尽管现在我们还是以 Spring 框架为基础讲 Rabbit MQ，但 Rabbit MQ 其实兼容很多语言和框架。之后的技术，例如 graphQL 和 gRPC，也是如此。而在最后一部分 k8s 中，为了开发效率，我们将会转向其它语言和框架。此外，前面学习的 Consul 也是这样。</p>
<h2 id="_1">基本概念</h2>
<p>消息队列中，经常讨论以下几个概念，</p>
<ul>
<li>生产者（Producer）：生产消息的服务，类似于之前响应式编程中的 Publisher</li>
<li>消费者（Consumer）：消费消息的服务，类似于之前响应式编程中的 Subscriber</li>
<li>队列（Queue）：存储消息的地方，生产者生产消息到队列，消费者消费消息</li>
<li>AMQP：Advanced Message Queuing Protocol，消息队列的协议，Rabbit MQ 就是 AMQP 的实现</li>
<li>通道（channel）：生产者和消费者之间的通道，生产者通过通道发送消息到队列，消费者通过通道消费消息</li>
<li>交换机（Exchange）：转发消息的地方，生产者发送消息到交换机，交换机将消息发送到队列</li>
</ul>
<h2 id="rabbit-mq">Rabbit MQ 六大模型</h2>
<p>Rabbit MQ 提供了六种常见的消息队列与产销者的组织方式，包括，</p>
<ul>
<li>缓冲队列（Buffer）：单个生产者，单个消费者。生产者的消息发送到队列，消费者从队列中消费消息。这时，消息队列只起到缓冲请求的作用。</li>
<li>工作队列（Work Queue）：单个生产者，多个消费者。生产者的消息发送到队列，多个消费者从队列中消费消息。这时，消息队列起到了负载均衡的作用。</li>
<li>扇出交换机（Fanout Exchange）：单个生产者，多个队列，多个消费者。生产者的消息发送到交换机，交换机将消息发送到所有的队列，每个队列有一个消费者。这时，消息队列起到了广播的作用。</li>
<li>路由交换机（Direct Exchange）：与扇出交换机类似，但是，消息会附带一个 routing key，交换机会根据 routing key 将消息发送到对应的队列。这时，消息队列起到了路由的作用。</li>
<li>主题交换机（Topic Exchange）：与路由交换机类似，但是，routing key 是一个通配符，交换机会根据通配符将消息发送到对应的队列。这时，消息队列依然是路由的作用。</li>
<li>远程过程调用（RPC）：生产者发送消息到队列，消费者消费消息后，再发送消息到另一个队列，生产者再消费消息。这时，消息队列起到了 RPC 的作用。</li>
</ul>
<p>其中，扇出交换机，路由交换机与主题交换机统称为订阅发布模式（Publish/Subscribe），它们是消息队列中最常见的模式。</p>
<h2 id="_2">项目配置</h2>
<p>依然使用 docker 来启动 Rabbit MQ，</p>
<pre><code class="language-yaml">services:
  rabbitmq:
    image: rabbitmq:4.0-rc-management
    environment:
      - RABBITMQ_DEFAULT_USER=user
      - RABBITMQ_DEFAULT_PASS=password
    ports:
      - 15672:15672
      - 5672:5672
</code></pre>
<p><code>15672</code>是管理的 WebUI，<code>5672</code>是 AMQP 的端口。</p>
<p>下文中，你可以直接使用 admin 账户，但是为了安全，最好还是创建一个新的账户。</p>
<h2 id="rabbit-mq_1">Rabbit MQ 管理界面</h2>
<p>Rabbit MQ 管理界面可以进行消息的查看，队列的查看，用户的管理等。在浏览器中输入 <code>http://localhost:15672</code>，输入账户密码，即可进入管理界面。创建用户很简单，输入用户名，密码和权限即可。</p>
<p><img alt="Rabbit MQ 用户管理界面" src="image.png" /></p>
<p>注意，只有 Admin 或者 Management 权限的用户才能进入管理界面。</p>
<p>此外，Rabbit MQ 有一个功能，叫 Virtual Host，这是用来隔离不同的服务的，可以类比于数据库中，先分库，再分表。在 Rabbit MQ 中，先分 Virtual Host，再分 Queue。Virtual Host 是一个逻辑概念，它是一个独立的空间，不同的 Virtual Host 之间是隔离的。在 Rabbit MQ 管理界面中，可以创建 Virtual Host。</p>
<p><img alt="Rabbit MQ 添加 Virtual Host" src="image-1.png" /></p>
<p>然后，点击用户管理界面的用户名，进入用户详情，使用 Set Permission 来设置用户能够访问的 Virtual Host。</p>
<p><img alt="Rabbit MQ 配置用户 Virtual Host 权限" src="image-2.png" /></p>
<h2 id="_3">缓冲队列模式</h2>
<p>现在，我们使用 Spring AMQP 来实现一个缓冲队列模式。首先，添加依赖，</p>
<pre><code class="language-groovy">implementation 'org.springframework.amqp:spring-rabbit:3.1.7'
</code></pre>
<p>如果是直接使用 Rabbit MQ，可以用下文的代码，</p>
<pre><code class="language-java">ConnectionFactory connectionFactory = new CachingConnectionFactory();
AmqpAdmin admin = new RabbitAdmin(connectionFactory);
admin.declareQueue(new Queue(&quot;myqueue&quot;));
AmqpTemplate template = new RabbitTemplate(connectionFactory);
template.convertAndSend(&quot;myqueue&quot;, &quot;foo&quot;);
String foo = (String) template.receiveAndConvert(&quot;myqueue&quot;);
</code></pre>
<p>但是，肯定是使用 Spring Bean 才更合理。</p>
<pre><code class="language-java">package io.github.fingerbone;

import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitAdmin;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public ConnectionFactory connectionFactory() {
        var factory = new CachingConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setUsername(&quot;user&quot;);
        factory.setPassword(&quot;password&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        return factory;
    }

    @Bean
    public AmqpAdmin amqpAdmin() {
        return new RabbitAdmin(connectionFactory());
    }

    @Bean
    public AmqpTemplate amqpTemplate() {
        return new RabbitTemplate(connectionFactory());
    }

    @Bean
    public Queue foodQueue() {
        return new Queue(&quot;food&quot;);
    }
}
</code></pre>
<p>如果你需要创建多个 Queue，使用我们之前讲依赖注入的相关知识即可。</p>
<pre><code class="language-java">@Bean(&quot;queue1&quot;)
public Queue queue1() {
    return new Queue(&quot;queue1&quot;);
}

@Bean(&quot;queue2&quot;)
public Queue queue2() {
    return new Queue(&quot;queue2&quot;);
}
</code></pre>
<p>然后我们添加一个生产者，</p>
<pre><code class="language-java">@RestController
@RequiredArgsConstructor
public class ProducerController {

    private final RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/apple&quot;)
    public Mono&lt;Void&gt; apple() {
        rabbitTemplate.convertAndSend(&quot;food&quot;, &quot;apple&quot;);
        return Mono.empty();
    }

}
</code></pre>
<p>调用后，可以发现消息已经发送到了队列中。</p>
<p><img alt="查看连接" src="image-3.png" /></p>
<p><img alt="查看队列内容" src="image-4.png" /></p>
<p>然后我们添加一个消费者，使用 <code>@RabbitListener</code> 注解，来监听队列。</p>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class Consumer {

    @RabbitListener(queues = &quot;food&quot;)
    @RabbitHandler
    public void consume(String message) {
        System.out.println(&quot;Yummy! I ate &quot; + message);
    }

}
</code></pre>
<p><code>@RabbitListener</code>注解用来监听队列，<code>queues</code>参数用来指定队列名，<code>@RabbitHandler</code>注解用来指定处理方法。如果加<code>@RabbitListener</code>到类上，它会作用在所有方法上。此时，如果有多个消费者，那么消息默认会被平均分配到每个消费者。消费者处理了消息后，消息就会从队列中删除。</p>
<p>Rabbit MQ 是完美转发的，如果你之前传递一个别的对象，那么这里也会接收到这个对象。例如，你传递了一个 <code>Apple</code> 对象，那么这里也会接收到这个对象，不过你需要把参数改成对应的类型。</p>
<p>如果你的生产者和消费者使用不同的语言，那么你需要使用序列化和反序列化。Rabbit MQ 默认使用的是 Java 的序列化和反序列化，但是这种方式不够通用，因此，你需要使用 JSON 或者 Protobuf 等方式。使用 MessageConverter 来指定序列化和反序列化的方式。</p>
<pre><code class="language-java">@Bean
public MessageConverter messageConverter() {
    return new Jackson2JsonMessageConverter();
}
</code></pre>
<p>然后，你需要在 RabbitTemplate 中指定 MessageConverter，</p>
<pre><code class="language-java">@Bean
public AmqpTemplate amqpTemplate() {
    var template = new RabbitTemplate(connectionFactory());
    template.setMessageConverter(messageConverter());
    return template;
}
</code></pre>
<h2 id="_4">工作队列模式</h2>
<p>工作队列模式是多个消费者消费同一个队列的消息。这时，消息队列起到了负载均衡的作用。在 Rabbit MQ 中，可以设置消费者的数量，这样就可以实现负载均衡。</p>
<pre><code class="language-java">@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
    var factory = new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory());
    factory.setConcurrentConsumers(3);
    factory.setMaxConcurrentConsumers(10);
    return factory;
}
</code></pre>
<p><code>SimpleRabbitListenerContainerFactory</code> 是用来设置消费者的数量的，<code>setConcurrentConsumers</code> 是设置初始消费者的数量，<code>setMaxConcurrentConsumers</code> 是设置最大消费者的数量。</p>
<p>如果你使用的微服务架构，那么你可以使用 Kubernetes 来自动扩容消费者的数量。如果是 Spring Cloud，那么你可以使用 Spring Cloud Stream 来自动扩容消费者的数量。</p>
<h2 id="_5">扇出交换机模式</h2>
<p>扇出交换机模式是一个生产者发送消息到一个交换机，交换机将消息发送到多个队列，每个队列有一个消费者。这时，消息队列起到了广播的作用。</p>
<p>首先，我们需要创建一个交换机，</p>
<pre><code class="language-java">@Bean
public FanoutExchange fanoutExchange() {
    return new FanoutExchange(&quot;fanout&quot;);
}
</code></pre>
<p>这里的交换机是 FanoutExchange。交换机的类型有四种，分别是 DirectExchange，FanoutExchange，TopicExchange 和 HeadersExchange。前三种对应了路由交换机，扇出交换机和主题交换机。最后一种是 HeadersExchange，它是根据消息头来路由的，这里不做讲解。</p>
<p>你也可以在 Rabbit MQ 管理界面中查看交换机。</p>
<p>然后，我们需要将队列绑定到交换机，</p>
<pre><code class="language-java">@Bean
public Binding foodBinding() {
    return BindingBuilder.bind(foodQueue()).to(fanoutExchange());
}
</code></pre>
<p>此外，为了演示，我们创建两个队列，</p>
<pre><code class="language-java">@Bean
public Queue trashQueue() {
    return new Queue(&quot;trash&quot;);
}

@Bean
public Binding trashBinding() {
    return BindingBuilder.bind(trashQueue()).to(fanoutExchange());
}
</code></pre>
<p>然后，我们创建两个消费者，</p>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class FoodConsumer {

    @RabbitListener(queues = &quot;food&quot;)
    @RabbitHandler
    public void consume(String message) {
        System.out.println(&quot;Yummy! I ate &quot; + message);
    }

    @RabbitListener(queues = &quot;trash&quot;)
    @RabbitHandler
    public void trash(String message) {
        System.out.println(&quot;Yuck! I threw away &quot; + message);
    }
}
</code></pre>
<p>最后，我们创建一个生产者，发送消息到交换机，</p>
<pre><code class="language-java">@GetMapping(&quot;/banana&quot;)
public Mono&lt;Void&gt; banana() {
    rabbitTemplate.convertAndSend(&quot;fanout&quot;, &quot;&quot;, &quot;banana&quot;);
    return Mono.empty();
}
</code></pre>
<p>第二个参数是 routing key，这里不需要，所以为空。</p>
<p>现在，如果我们访问<code>/banana</code>，那么两个消费者都会收到消息，并作出相应的处理。</p>
<h2 id="_6">路由交换机模式</h2>
<p>路由交换机模式是一个生产者发送消息到一个交换机，交换机根据 routing key 将消息发送到对应的队列。这时，消息队列起到了路由的作用。</p>
<p>首先，我们需要创建一个交换机，</p>
<pre><code class="language-java">@Bean
public DirectExchange directExchange() {
    return new DirectExchange(&quot;direct&quot;);
}
</code></pre>
<p>这里我们用两个新的队列，</p>
<pre><code class="language-java">@Bean
public Queue fruitQueue() {
    return new Queue(&quot;fruit&quot;);
}

@Bean
public Queue vegetableQueue() {
    return new Queue(&quot;vegetable&quot;);
}
</code></pre>
<p>然后，我们需要将队列绑定到交换机，</p>
<pre><code class="language-java">@Bean
public Binding fruitBinding() {
    return BindingBuilder.bind(fruitQueue()).to(directExchange()).with(&quot;fruit&quot;);
}

@Bean
public Binding vegetableBinding() {
    return BindingBuilder.bind(vegetableQueue()).to(directExchange()).with(&quot;vegetable&quot;);
}
</code></pre>
<p>然后，我们创建两个消费者，</p>
<pre><code class="language-java">@Component
@RequiredArgsConstructor
public class FruitConsumer {

    @RabbitListener(queues = &quot;fruit&quot;)
    @RabbitHandler
    public void consume(String message) {
        System.out.println(&quot;Yummy! I ate &quot; + message);
    }

    @RabbitListener(queues = &quot;vegetable&quot;)
    @RabbitHandler
    public void trash(String message) {
        System.out.println(&quot;Wonderful! I ate &quot; + message);
    }
}
</code></pre>
<p>最后，我们创建一个生产者，发送消息到交换机，</p>
<pre><code class="language-java">@GetMapping(&quot;/carrot&quot;)
public Mono&lt;Void&gt; carrot() {
    rabbitTemplate.convertAndSend(&quot;direct&quot;, &quot;vegetable&quot;, &quot;carrot&quot;);
    return Mono.empty();
}

@GetMapping(&quot;/grape&quot;)
public Mono&lt;Void&gt; grape() {
    rabbitTemplate.convertAndSend(&quot;direct&quot;, &quot;fruit&quot;, &quot;grape&quot;);
    return Mono.empty();
}
</code></pre>
<p>现在，如果我们访问<code>/carrot</code>，那么只有第一个消费者会收到消息，如果我们访问<code>/grape</code>，那么只有第二个消费者会收到消息。</p>
<h2 id="_7">主题交换机模式</h2>
<p>主题交换机模式是一个生产者发送消息到一个交换机，交换机根据通配符将消息发送到对应的队列。这时，消息队列依然是路由的作用。</p>
<p>首先，我们需要创建一个交换机，</p>
<pre><code class="language-java">@Bean
public TopicExchange topicExchange() {
    return new TopicExchange(&quot;topic&quot;);
}
</code></pre>
<p>然后，我们需要将队列绑定到交换机，</p>
<pre><code class="language-java">@Bean
public Binding fruitBinding() {
    return BindingBuilder.bind(fruitQueue()).to(topicExchange()).with(&quot;fruit.*&quot;);
}

@Bean
public Binding vegetableBinding() {
    return BindingBuilder.bind(vegetableQueue()).to(topicExchange()).with(&quot;vegetable.*&quot;);
}
</code></pre>
<p>这里的通配符有两种，<code>*</code>和<code>#</code>，<code>*</code>表示一个单词，<code>#</code>表示多个单词。</p>
<p>然后，我们依然使用之前的消费者，唯一区别是，我们需要修改 routing key 为主题的形式，即<code>{first}.{second}.{third}</code>。</p>
<pre><code class="language-java">@GetMapping(&quot;/apple&quot;)
public Mono&lt;Void&gt; apple() {
    rabbitTemplate.convertAndSend(&quot;topic&quot;, &quot;fruit.apple&quot;, &quot;apple&quot;);
    return Mono.empty();
}

@GetMapping(&quot;/tomato&quot;)
public Mono&lt;Void&gt; tomato() {
    rabbitTemplate.convertAndSend(&quot;topic&quot;, &quot;vegetable.tomato&quot;, &quot;tomato&quot;);
    return Mono.empty();
}
</code></pre>
<p>现在，如果我们访问<code>/apple</code>，那么只有第一个消费者会收到消息，如果我们访问<code>/tomato</code>，那么只有第二个消费者会收到消息。</p>
<p>从上面可以看出，主题交换机模式只是路由交换机模式的一个扩展，它可以根据通配符来路由消息。</p>
<h2 id="_8">可靠性保障</h2>
<p>现在我们考虑添加了消息队列系统的可靠性保障：整个链路是生产者，交换机，队列，消费者。交换机与队列间的可靠性由 Rabbit MQ 保障，我们只要考虑生产者可靠性和消费者可靠性。</p>
<h3 id="_9">生产者可靠性</h3>
<p>首先，对于连接的可靠性，可以在 <code>application.yml</code> ，可以设置 RabbitMQ 的连接超时和重连机制，以确保在网络抖动或 RabbitMQ 服务暂时不可用时，生产者能自动恢复连接。</p>
<pre><code>spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    # 配置连接超时（毫秒）
    connection-timeout: 15000
    # 启用自动重连
    listener:
      simple:
        retry:
          enabled: true
          max-attempts: 5
          initial-interval: 1000
          multiplier: 2.0
          max-interval: 10000
</code></pre>
<p>其次，还有生产者确认机制，</p>
<pre><code>spring:
  rabbitmq:
    publisher-confirm-type: correlated
</code></pre>
<p><code>publisher-confirm-type</code> 有publisher-confirm-type 有以下几种配置选项，用于控制 RabbitMQ 消息的发布确认机制：</p>
<p>none 即关闭生产者确认机制，RabbitMQ 不会为生产者的消息发布提供任何确认。优点：性能较高。缺点：无法保障消息的可靠投递，如果消息在传输过程中丢失，生产者无法得知。适用场景：对消息可靠性要求较低的非关键场景。</p>
<p>correlated 即启用异步的生产者确认机制，RabbitTemplate 会通过回调函数获取消息是否成功到达交换机。优点：性能较好，且支持异步回调，可以精准追踪每条消息的状态。缺点：需要额外实现回调逻辑。适用场景：大多数业务场景，需关注消息是否成功发送到 RabbitMQ。</p>
<p>录入，可以这样配置回调，</p>
<pre><code class="language-java">@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
    rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; {
        if (ack) {
            System.out.println(&quot;Message delivered successfully: &quot; + correlationData);
        } else {
            System.err.println(&quot;Message delivery failed: &quot; + cause);
        }
    });
    return rabbitTemplate;
}
</code></pre>
<p>在 <code>correlationData</code> 中包含了完整的原始的消息，如果需要可以直接重发。</p>
<p>注意，这个回调的方法签名可能会随版本不同有一些改动。</p>
<p>simple 即启用同步的生产者确认机制，RabbitTemplate 的 convertAndSend 方法会阻塞，直到确认消息已被 RabbitMQ 成功接收。优点：实现简单，确认结果清晰。缺点：性能极差，一般不使用。</p>
<p>例如，</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    publisher-confirm-type: simple
</code></pre>
<pre><code class="language-java">@GetMapping(&quot;/sendSyncMessage&quot;)
public Mono&lt;Void&gt; sendSyncMessage() {
    try {
        rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;routingKey&quot;, &quot;message&quot;);
        System.out.println(&quot;Message sent successfully!&quot;);
    } catch (Exception e) {
        System.err.println(&quot;Message delivery failed: &quot; + e.getMessage());
    }
    return Mono.empty();
}
</code></pre>
<p>通常推荐使用 Correlate 模式。</p>
<p>此外还可以配置 TTL 即一个 Time To Live 属性，可以加在每一个消息中。当一个消息挤压超过 TTL，会自动 reject，即丢弃消息。</p>
<pre><code class="language-java">@GetMapping(&quot;/sendMessageWithTTL&quot;)
public Mono&lt;Void&gt; sendMessageWithTTL() {
    // 创建消息属性，指定 TTL 为 30 秒
    MessagePostProcessor messagePostProcessor = message -&gt; {
        message.getMessageProperties().setExpiration(&quot;30000&quot;); // TTL = 30 秒
        return message;
    };

    // 发送消息到交换机，携带自定义 TTL
    rabbitTemplate.convertAndSend(&quot;example.exchange&quot;, &quot;example.routingKey&quot;, &quot;Message with TTL&quot;, messagePostProcessor);

    System.out.println(&quot;Message sent with TTL of 30 seconds&quot;);
    return Mono.empty();
}
</code></pre>
<p>还可以给整个队列配置 TTL，</p>
<pre><code class="language-java">@Bean
public Queue exampleQueue() {
    return QueueBuilder.durable(&quot;exampleQueue&quot;)
            .withArgument(&quot;x-message-ttl&quot;, 60000) // 设置消息的存活时间为 60 秒（60000 毫秒）
            .withArgument(&quot;x-dead-letter-exchange&quot;, &quot;dlx.exchange&quot;) // 配置死信交换机
            .withArgument(&quot;x-dead-letter-routing-key&quot;, &quot;dlx.routingKey&quot;) // 配置死信路由键
            .build();
}
</code></pre>
<p>reject 尽管是丢弃消息，但你也可以把丢弃的消息称放到一个死信交换机中，然后放到死信队列。这样这些信息可以被收集。</p>
<p>这里的 <code>durable</code> 是指久化队列，会在后面介绍。</p>
<h3 id="_10">消费者可靠性</h3>
<p>消费者的连接可靠性同样可以用之前的配置保障。</p>
<p>对于消息处理的可靠性，可以使用确认机制，</p>
<p>第一种模式是手动模式，</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: manual
</code></pre>
<pre><code class="language-java">@RabbitListener(queues = &quot;exampleQueue&quot;)
public void processMessage(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {
    try {
        // 处理消息逻辑
        System.out.println(&quot;Processing message: &quot; + message);

        // 手动确认消息
        channel.basicAck(deliveryTag, false);
    } catch (Exception e) {
        System.err.println(&quot;Failed to process message: &quot; + e.getMessage());

        try {
            // 处理失败，拒绝消息并重新投递
            channel.basicNack(deliveryTag, false, true);
        } catch (IOException ioException) {
            System.err.println(&quot;Failed to nack message: &quot; + ioException.getMessage());
        }
    }
}
</code></pre>
<p>更推荐自动模式：当出现业务异常时，自动返回 nack 请求，nack 消息会导致消息队列将发送的消息重新放回队列中；当 Rabbit MQ 通信异常时，或接受到错误的消息，自动返回 reject 请求，这个消息被丢弃。</p>
<p>注意，这时要配置一个最大重试次数，不然会导致消息挤压。当消息重试超过次数时，同样会 reject。</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto  # 自动确认模式
        retry:
          enabled: true         # 启用消费者重试机制
          max-attempts: 5       # 最大重试次数
          initial-interval: 1000  # 初始重试间隔（毫秒）
          multiplier: 2.0         # 每次重试间隔倍增
          max-interval: 10000     # 最大重试间隔（毫秒）
        default-requeue-rejected: false # 超过重试次数后不重新入队，避免死循环
</code></pre>
<p>当然你也可以配置死信交换机。</p>
<h3 id="_11">持久化队列</h3>
<p>在 RabbitMQ 中，持久化队列的目的是确保即使 RabbitMQ 服务器重启，队列中的消息也不会丢失。持久化功能适用于队列和消息两部分。</p>
<p>创建队列时，可以设置其为持久化队列。持久化队列会被保存到磁盘中。</p>
<pre><code class="language-java">@Bean
public Queue durableQueue() {
    return QueueBuilder.durable(&quot;durableQueue&quot;).build(); // 声明持久化队列
}
</code></pre>
<p>也可以设定持久化消息，</p>
<pre><code class="language-java">rabbitTemplate.convertAndSend(&quot;durableExchange&quot;, &quot;durableKey&quot;, &quot;Persistent Message&quot;, message -&gt; {
    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 设置消息持久化
    return message;
});
</code></pre>
<h2 id="_12">总结</h2>
<p>Rabbit MQ 是一个 AMQP 的消息队列，它是一个开源的消息队列，可以用于构建分布式系统。Rabbit MQ 是一个消息中间件，它是一个独立的服务，用于存储消息，然后消费者消费消息。Rabbit MQ 有六种常见的消息队列与产销者的组织方式，包括缓冲队列，工作队列，扇出交换机，路由交换机，主题交换机和远程过程调用。这些模式可以满足不同的需求，例如，负载均衡，广播，路由等。这里，我们除了远程过程调用，其他的模式都进行了实现。</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
