<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-12" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Reactor | 微服务速成</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://finger-bone.github.io/micro-service-crashcourse/docs/12"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Reactor | 微服务速成"><meta data-rh="true" name="description" content="Spring Cloud 微服务的内容告一段落。在 Spring Cloud 部分，我们学习了使用 Consul，Load Balancer，Spring Interface Client 与 OpenFeign，Resilience4j，MicroMeter，Gateway，Seata。这是现在 Spring Cloud 官方最推荐的一套组件。诚然，还有其它一些组件也很重要，主要是 Spring Cloud Alibaba 的组件，Nacos 与 Sentinel，Seata 也属于 Spring Cloud Alibaba 的组件，但是我们已经介绍了它。Nacos 和 Sentinel 的使用方法与 Consul 和 Resilience4j 类似，所以这里不再介绍，有了前面的基础，你可以很容易的学习它们。"><meta data-rh="true" property="og:description" content="Spring Cloud 微服务的内容告一段落。在 Spring Cloud 部分，我们学习了使用 Consul，Load Balancer，Spring Interface Client 与 OpenFeign，Resilience4j，MicroMeter，Gateway，Seata。这是现在 Spring Cloud 官方最推荐的一套组件。诚然，还有其它一些组件也很重要，主要是 Spring Cloud Alibaba 的组件，Nacos 与 Sentinel，Seata 也属于 Spring Cloud Alibaba 的组件，但是我们已经介绍了它。Nacos 和 Sentinel 的使用方法与 Consul 和 Resilience4j 类似，所以这里不再介绍，有了前面的基础，你可以很容易的学习它们。"><link data-rh="true" rel="icon" href="/micro-service-crashcourse/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://finger-bone.github.io/micro-service-crashcourse/docs/12"><link data-rh="true" rel="alternate" href="https://finger-bone.github.io/micro-service-crashcourse/docs/12" hreflang="en"><link data-rh="true" rel="alternate" href="https://finger-bone.github.io/micro-service-crashcourse/docs/12" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/micro-service-crashcourse/assets/css/styles.0906fbfd.css">
<script src="/micro-service-crashcourse/assets/js/runtime~main.6d8a01af.js" defer="defer"></script>
<script src="/micro-service-crashcourse/assets/js/main.4cb37dc3.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/micro-service-crashcourse/"><b class="navbar__title text--truncate">微服务速成</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/micro-service-crashcourse/docs/01">Notes</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/01">回到 Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/02">回到 Java</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/03">Consul 服务注册与发现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/04">Consul 配置管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/05">LoadBalancer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/06">Spring Interface Client 与 OpenFeign REST 服务调用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/07">Resilience4j 服务熔断和降级</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/08">Resilience4j Bulkhead, RateLimiter, TimeLimiter 限流</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/09">MicroMeter Tracing 服务链路追踪</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/10">GateWay 网关</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/11">分布式事务 Seata</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/micro-service-crashcourse/docs/12">Reactor</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/13">WebFlux</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/14">Spring Security</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/15">Spring Security OAuth 认证与 KeyCloak</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/16">Rabbit MQ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/17">GraphQL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/18">gRPC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/19">后端框架一览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/20">k8s 无状态服务基本部署</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/21">helm 打包 istio 网关与 k8s 命令行工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/22">k8s 无状态服务</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/23">k8s 有状态服务</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/24">服务网格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/25">Nacos 服务治理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/26">Sentinel</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/27">Kafka 高性能消息队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/28">Redis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/29">OTel-LGTM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/30">Dubbo RPC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/31">Nginx</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/32">Treafik</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/micro-service-crashcourse/docs/33">Citus</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/micro-service-crashcourse/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Reactor</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Reactor</h1></header>
<p>Spring Cloud 微服务的内容告一段落。在 Spring Cloud 部分，我们学习了使用 Consul，Load Balancer，Spring Interface Client 与 OpenFeign，Resilience4j，MicroMeter，Gateway，Seata。这是现在 Spring Cloud 官方最推荐的一套组件。诚然，还有其它一些组件也很重要，主要是 Spring Cloud Alibaba 的组件，Nacos 与 Sentinel，Seata 也属于 Spring Cloud Alibaba 的组件，但是我们已经介绍了它。Nacos 和 Sentinel 的使用方法与 Consul 和 Resilience4j 类似，所以这里不再介绍，有了前面的基础，你可以很容易的学习它们。</p>
<p>现在，我们将学习一些 Spring 的高级内容，之后再回到微服务，学习基于 kubernetes 的微服务。</p>
<p>这些内容主要包括，</p>
<ul>
<li>WebFlux，异步的 Spring Web</li>
<li>Spring Security，Spring 安全框架；KeyCloak，OIDC 认证服务器</li>
<li>消息队列，Rabbit MQ</li>
<li>非 HTTP 协议，包括 graphQL 和 RPC，RPC 将基于 gRPC 进行介绍</li>
</ul>
<p>首先，我们学习 WebFlux。Spring 框架我们之前已经学过，因此我们重点学习 Reactor，它是 WebFlux 的基础。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="webflux-简介">WebFlux 简介<a href="#webflux-简介" class="hash-link" aria-label="Direct link to WebFlux 简介" title="Direct link to WebFlux 简介">​</a></h2>
<p>前面我们讲过，Spring 自己是一个基于 Bean 的框架。而 Spring Web 是我们实际开发 Web 程序使用的框架，它是个基于 Servlet 和 Spring 的框架，它有自己的 Spring Boot Starter，可以很方便的使用。</p>
<p>其实，Spring Web 的全名是 Spring Web MVC，但 MVC 已经没人关心了。</p>
<p>但是，与 Spring Web 并行的还有一套框架，叫做 Spring WebFlux。Spring WebFlux 是一个基于 Reactor 的框架，它是一个异步的框架，可以用于构建响应式的 Web 应用程序。它也是基于 Spring 容器，但是它的异步引擎是 Reactor，而服务器是 Netty。Reactor 为 WebFlux 提供了异步的能力，Netty 为 WebFlux 提供了异步的服务器。</p>
<p>相比于 Spring Web，Spring WebFlux 有更高的并发能力。然而，由于 WebFlux 较为年轻，Spring 的整个生态都是围绕 Spring Web 的，所以 Spring WebFlux 可能会遇到一些不兼容问题，但并不严重。但整体而言，坐拥整个 Spring 生态的 Spring WebFlux 是一个很有前途的框架。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="java-标准库异步编程">Java 标准库异步编程<a href="#java-标准库异步编程" class="hash-link" aria-label="Direct link to Java 标准库异步编程" title="Direct link to Java 标准库异步编程">​</a></h2>
<p>我们先看为什么要引入 Reactor。</p>
<p>Java 在 8 之后引入了 Future，但是 Future 设计的太差了，以至于你必须手动实现 EventLoop，例如，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService executor = Executors.newFixedThreadPool(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Future&lt;Integer&gt; future = executor.submit(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (!future.isDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Waiting...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(future.get());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这是一个非常糟糕的设计因此，Java 在 8 之后引入了 CompletableFuture，它比 Future 好用多了，例如，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">future.thenAccept(System.out::println);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>显然，这个已经很像其它语言的 Promise 了。但是很可惜，Java 至今还没有引入 async-await，因此经典的回调地狱还是会出现。</p>
<p>不过，回调地狱不只有一种解决方案，除了大部分语言采用的 async-await，还有一种解决方案，就是响应式编程，这就是 Reactor。</p>
<p>不过，Java 在后续的 Java 9 之后引入了 Flow，它设计的和 Reactor 类似。具体而言，它的效果是，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Flow.Publisher&lt;Integer&gt; publisher = subscriber -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    subscriber.onNext(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    subscriber.onComplete();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Flow.Subscriber&lt;Integer&gt; subscriber = new Flow.Subscriber&lt;&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSubscribe(Flow.Subscription subscription) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscription.request(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onNext(Integer item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onError(Throwable throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throwable.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onComplete() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Complete&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">publisher.subscribe(subscriber);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>多少有点太啰嗦了。而 Reactor 利用函数式编程的特性，可以更简单的实现这个功能，像是，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Flux.just(1).subscribe(System.out::println);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>要简单得多。这就是为什么尽管有了 Flow，但是 Reactor 仍然有市场。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="响应式编程的核心概念">响应式编程的核心概念<a href="#响应式编程的核心概念" class="hash-link" aria-label="Direct link to 响应式编程的核心概念" title="Direct link to 响应式编程的核心概念">​</a></h2>
<p>响应式编程本质就是经典的流式编程，但是它与传统的流式编程有一些不同。</p>
<ul>
<li>响应式编程是异步的，而不是同步的。这意味着你可以在等待一个操作完成的时候做其它事情。而在流式编程中，本质只是一个循环。</li>
<li>响应式编程是基于事件的，而不是基于数据的。这意味着你可以在数据到达的时候处理数据，而不是等待数据到达。</li>
<li>响应式编程是惰性的，而不是及时的。这意味着你可以在需要的时候才处理数据，而不是一次性处理所有数据。</li>
</ul>
<p>响应式编程有两个核心概念，一个是 Publisher，一个是 Subscriber。两者在 Reactor 中都是 Mono 和 Flux，而这两个东西本质上是函数式编程中的 Monad。</p>
<p>下面关于 Monad 的内容，如果不理解可以跳过，不影响工程上的知识和使用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="monad">Monad<a href="#monad" class="hash-link" aria-label="Direct link to Monad" title="Direct link to Monad">​</a></h3>
<p>Monad 是函数式编程中的一个概念。尽管有些教程写的很复杂，但是其实很简单。Monad 本质上是一种映射。我们用两个空间来诠释 Monad，真值空间和像空间。真值空间是我们熟悉的空间，它包含了所有的真值。而像空间是 Monad 的空间，它包含了 Monad 的值。</p>
<p>Monad 是一个包含三个关键要素的结构：</p>
<ul>
<li>类型构造器（Type Constructor）：将普通的值（真值）映射到像空间中。这类似于在 Java 中的泛型类型，如<code>Optional&lt;T&gt;</code>，它将一个值包裹在一个容器内。类型构造器本质上定义了一个新的数据类型，这个类型包含了原始值及其附加的计算上下文。</li>
<li>unit（也称为 return 或 pure）：一个函数，用于将真值空间中的元素转换为像空间中的 Monad。换句话说，它将普通的值放入 Monad 中。例如，在 Optional 中，你可以使用<code>Optional.of</code>来将一个值放入 Optional Monad 中。</li>
<li>bind（也称为 flatMap，或<code>&gt;&gt;=</code>）：一个函数，用于对像空间中的 Monad 进行操作。</li>
</ul>
<p>也就是说，Monad 先把某个值打包，然后对这个打包好的值进行运算，然后再取出来。这个打包好的值就是像空间中的 Monad。</p>
<p>这种操作看起来可能没有什么意义，但下面这个例子可能会让你明白它的方便之处。即有时候，真值空间内的运算可能没有全局的算子，即没有全局的函数来处理所有情况。还使用 Optional 为例子，例如用户输入一个数字，你想要对这个数字开根号，但是用户可能输入了负数，或者是空值。这时候，你就需要对这个数字进行检查，然后再进行开根号。这个检查的过程就是 Monad 的 bind 过程。</p>
<p>例如，下面的代码可以完成这个 Nomad 的过程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class NomadOfRoot {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Double value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final boolean isNegative;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NomadOfRoot(Double value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.isNegative = value &lt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NomadOfRoot root() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isNegative || value == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NomadOfRoot(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NomadOfRoot((Double) Math.sqrt(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NomaOfRoot add(NomadOfRoot other) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value == null || other.value == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NomadOfRoot(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NomadOfRoot(value + other.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Double getValue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Double result = (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new NomadOfRoot(1.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .add(new NomadOfRoot(2.0).root())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .root()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .add(new NomadOfRoot(-3.0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .root()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .getValue()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这样子，如果我们的所有接口都返回 NomadOfRoot，那么我们就不用再做额外的检查了，因为 NomadOfRoot 会自动检查并返回正确的值。</p>
<p>目前我们的操作还很少。但是如果要链式调用几十个方法呢？这时候 Monad 就显得很方便了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="响应式编程中的-monad">响应式编程中的 Monad<a href="#响应式编程中的-monad" class="hash-link" aria-label="Direct link to 响应式编程中的 Monad" title="Direct link to 响应式编程中的 Monad">​</a></h3>
<p>响应式编程本质就是将数据包装成异步 Monad，这个 Monad 要么处于 Pending 阶段，没有求值；要么已经完成，然后对这个 Monad 进行操作。这个操作是一个管线，它是一个链式的操作，每个操作都是一个 Monad，这个 Monad 会在数据到达的时候进行操作。</p>
<p>在 Reactor 中，这个 Monad 是 Flux 类，Mono 则是 Flux 的特例。对比上面对 Monad 的介绍，我们列出 Flux 的三个要素：</p>
<ul>
<li>类型构造器：使用<code>Flux.just</code>来构造一个 Flux。但注意，Flux 保存的是一个列表，而不是一个值，因此，例如<code>Flux&lt;Integer&gt;</code>，可以保存多个 Integer，要这样写<code>Flux.just(1, 2, 3)</code>。</li>
<li>unit：要把 Flux 对象变成普通的值，可以使用<code>block</code>方法，例如<code>Flux.just(1).blockFirst()</code>。</li>
<li>bind：Flux 的 bind 是<code>map</code>，<code>flatMap</code>，<code>filter</code>等方法。</li>
</ul>
<p>而 Mono 类是一种特殊的 Flux，它只能保存一个值。显然，Flux 可以被拆成很多个 Mono，而 Mono 也可以被合并成一个 Flux。前者使用<code>next</code>方法，后者使用<code>concat</code>方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="publisher-subscribe-与-pipe">Publisher， Subscribe 与 Pipe<a href="#publisher-subscribe-与-pipe" class="hash-link" aria-label="Direct link to Publisher， Subscribe 与 Pipe" title="Direct link to Publisher， Subscribe 与 Pipe">​</a></h3>
<p>Publisher 与 Subscriber 是 Reactor 的两个核心接口。Publisher 是一个生产者，它可以生产数据。Subscriber 是一个消费者，它可以消费数据。简单的来说，Publisher 必须产生 Flux，而 Subscriber 必须消费 Flux。</p>
<p>例如，下面的代码是一个 Publisher，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Flux&lt;Integer&gt; publisher = Flux.just(1, 2, 3);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>而下面的代码是一个 Subscriber，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">publisher.subscribe(System.out::println);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当然，把所有数据取出来也算是一种消费，这时候可以使用<code>block</code>方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">publisher.blockLast();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>而数据之间的转换，则是通过管线方法（Pipe）来实现的。具体而言，<code>map</code>方法是最常用的 Pipe 方法，它可以对数据进行转换。例如，</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Flux&lt;Integer&gt; publisher = Flux.just(1, 2, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; l = publisher.map(i -&gt; i * 2).collectList().block();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>综上，一个完整的管线就是，publisher 从一般的数据转换成 Flux，若干 Pipe 方法对数据进行转换，从 Flux 转成 Flux，最后通过 subscribe方法消费数据。</p>
<p>常用的内建 Publisher 有，</p>
<ul>
<li><code>Flux.just</code>：将一个或若干个元素转换成 Flux。</li>
<li><code>Flux.fromArray</code>：将一个数组转换成 Flux。</li>
<li><code>Flux.fromIterable</code>：将一个 Iterable 转换成 Flux。</li>
<li><code>Flux.fromStream</code>：将一个 Stream 转换成 Flux。</li>
<li><code>Flux.range</code>：将一个范围内的整数转换成 Flux。</li>
<li><code>Mono.just</code>：将一个元素转换成 Mono。</li>
<li><code>Mono.empty</code>：将一个空值转换成 Mono。</li>
<li><code>Mono.error</code>：将一个错误转换成 Mono。</li>
</ul>
<p>常用的 Pipe 方法有，</p>
<ul>
<li><code>flux.map(func)</code>：对 Flux 中的每个元素，执行函数，将返回值收集成新的 Flux。</li>
<li><code>flux.flatMap(func)</code>：对 Flux 中的每个元素，执行函数，函数应当返回一个元素列表，最后会把每个元素列表连接成一个新的 Flux。</li>
<li><code>flux.filter(func)</code>：对 Flux 中的每个元素，执行函数，函数应当返回一个布尔值，最后会把所有返回 true 的元素收集成新的 Flux。</li>
<li><code>flux.collectList()</code>：将 Flux 中的所有元素收集成一个列表的 Mono。即<code>Flux&lt;T&gt;</code>变成<code>Mono&lt;List&lt;T&gt;&gt;</code>。</li>
<li><code>flux.first()</code>：将 Flux 中的第一个元素收集成一个 Mono。</li>
<li><code>flux.last()</code>：将 Flux 中的最后一个元素收集成一个 Mono。</li>
<li><code>flux.index(index)</code>：将 Flux 中的第 index 个元素收集成一个 Mono。</li>
<li><code>mono.map(func)</code>：对 Mono 中的元素，执行函数，将返回值收集成新的 Mono。</li>
</ul>
<p>常用的 Subscribe 方法有，</p>
<ul>
<li><code>flux.subscribe()</code>：订阅一个 Flux，但是不做任何事情。</li>
<li><code>flux.subscribe(func)</code>：订阅一个 Flux，对每个元素执行函数。</li>
<li><code>flux.blockLast()</code>：订阅一个 Flux，取出最后一个元素。</li>
<li><code>flux.blockFirst()</code>：订阅一个 Flux，取出第一个元素。</li>
<li><code>flux.block()</code>：订阅一个 Flux，取出所有元素。</li>
<li><code>mono.block()</code>：订阅一个 Mono，取出元素。</li>
<li><code>mono.subscribe()</code>：订阅一个 Mono，但是不做任何事情。</li>
<li><code>mono.subscribe(func)</code>：订阅一个 Mono，对元素执行函数。</li>
</ul>
<p>注意，上面的所有方法只是声明管线，并不会真正执行管线。只有 Subscribe 方法才会真正执行管线。执行时，各个元素是异步执行的。</p>
<p>此外，Subscribe 方法不能嵌套。一旦数值进入了 Monad，只能使用 Pipe 方法进行处理。例如，在 Webflux 中，框架会自动为你 Subscibe Monad，因此不能在代码中使用 Subscribe 方法，处理时必须使用响应式语法。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/finger-bone/micro-service-crashcourse/blob/main/docs/12.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/micro-service-crashcourse/docs/11"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">分布式事务 Seata</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/micro-service-crashcourse/docs/13"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">WebFlux</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#webflux-简介" class="table-of-contents__link toc-highlight">WebFlux 简介</a></li><li><a href="#java-标准库异步编程" class="table-of-contents__link toc-highlight">Java 标准库异步编程</a></li><li><a href="#响应式编程的核心概念" class="table-of-contents__link toc-highlight">响应式编程的核心概念</a><ul><li><a href="#monad" class="table-of-contents__link toc-highlight">Monad</a></li><li><a href="#响应式编程中的-monad" class="table-of-contents__link toc-highlight">响应式编程中的 Monad</a></li><li><a href="#publisher-subscribe-与-pipe" class="table-of-contents__link toc-highlight">Publisher， Subscribe 与 Pipe</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>